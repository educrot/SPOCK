:mod:`spe_schedule`
===================

.. py:module:: spe_schedule


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   spe_schedule.ObservingBlock
   spe_schedule.Scorer
   spe_schedule.TransitionBlock
   spe_schedule.Schedule
   spe_schedule.Slot
   spe_schedule.Scheduler
   spe_schedule.SequentialScheduler
   spe_schedule.PriorityScheduler
   spe_schedule.Transitioner
   spe_schedule.DateElsa
   spe_schedule.SimpleScheduler



.. py:class:: ObservingBlock(target, duration, priority, configuration={}, constraints=None)

   Bases: :class:`object`

   An observation to be scheduled, consisting of a target and associated
   constraints on observations.

   .. method:: __repr__(self)


      Return repr(self).


   .. method:: constraints_scores(self)
      :property:



   .. method:: from_exposures(cls, target, priority, time_per_exposure, number_exposures, readout_time=0 * u.second, configuration={}, constraints=None)
      :classmethod:




.. py:class:: Scorer(blocks, observer, schedule, global_constraints=[])

   Bases: :class:`object`

   Returns scores and score arrays from the evaluation of constraints on
   observing blocks

   .. method:: create_score_array(self, time_resolution=1 * u.minute)


      this makes a score array over the entire schedule for all of the
      blocks and each `~astroplan.Constraint` in the .constraints of
      each block and in self.global_constraints.

      :param time_resolution: the time between each scored time
      :type time_resolution: `~astropy.units.Quantity`

      :returns: **score_array** -- array with dimensions (# of blocks, schedule length/ ``time_resolution``
      :rtype: `~numpy.ndarray`


   .. method:: from_start_end(cls, blocks, observer, start_time, end_time, global_constraints=[])
      :classmethod:


      for if you don't have a schedule/ aren't inside a scheduler



.. py:class:: TransitionBlock(components, start_time=None)

   Bases: :class:`object`

   Parameterizes the "dead time", e.g. between observations, while the
   telescope is slewing, instrument is reconfiguring, etc.

   .. method:: __repr__(self)


      Return repr(self).


   .. method:: end_time(self)
      :property:



   .. method:: components(self)
      :property:



   .. method:: from_duration(cls, duration)
      :classmethod:




.. py:class:: Schedule(start_time, end_time, constraints=None)

   Bases: :class:`object`

   An object that represents a schedule, consisting of a list of
   `~astroplan.scheduling.Slot` objects.

   .. method:: __repr__(self)


      Return repr(self).


   .. method:: observing_blocks(self)
      :property:



   .. method:: scheduled_blocks(self)
      :property:



   .. method:: open_slots(self)
      :property:



   .. method:: to_table(self, show_transitions=True, show_unused=False)



   .. method:: new_slots(self, slot_index, start_time, end_time)


      Create new slots by splitting a current slot.

      :param slot_index: The index of the slot to split
      :type slot_index: int
      :param start_time: The start time for the slot to create
      :type start_time: `~astropy.time.Time`
      :param end_time: The end time for the slot to create
      :type end_time: `~astropy.time.Time`

      :returns: **new_slots** -- The new slots created
      :rtype: list of `~astroplan.scheduling.Slot` s


   .. method:: insert_slot(self, start_time, block)


      Insert a slot into schedule and associate a block to the new slot.

      :param start_time: The start time for the new slot.
      :type start_time: `~astropy.time.Time`
      :param block: The observing block to insert into new slot.
      :type block: `~astroplan.scheduling.ObservingBlock`

      :returns: **slots** -- The new slots in the schedule.
      :rtype: list of `~astroplan.scheduling.Slot` objects


   .. method:: change_slot_block(self, slot_index, new_block=None)


      Change the block associated with a slot.

      This is currently designed to work for TransitionBlocks in PriorityScheduler
      The assumption is that the slot afterwards is open and that the start time
      will remain the same.

      If the block is changed to None, the slot is merged with the slot
      afterwards to make a longer slot.

      :param slot_index: The slot to edit
      :type slot_index: int
      :param new_block: The new transition block to insert in this slot
      :type new_block: `~astroplan.scheduling.TransitionBlock`, default None



.. py:class:: Slot(start_time, end_time)

   Bases: :class:`object`

   A time slot consisting of a start and end time

   .. method:: duration(self)
      :property:



   .. method:: split_slot(self, early_time, later_time)


      Split this slot and insert a new one.

      Will return the new slots created, which can either
      be one, two or three slots depending on if there is
      space remaining before or after the inserted slot.

      :param early_time: The start time of the new slot to insert.
      :type early_time: `~astropy.time.Time`
      :param later_time: The end time of the new slot to insert.
      :type later_time: `~astropy.time.Time`



.. py:class:: Scheduler(constraints, observer, transitioner=None, gap_time=5 * u.min, time_resolution=20 * u.second)

   Bases: :class:`object`

   Schedule a set of `~astroplan.scheduling.ObservingBlock` objects

   .. attribute:: __metaclass__
      

      

   .. method:: __call__(self, blocks, schedule)


      Schedule a set of `~astroplan.scheduling.ObservingBlock` objects.

      :param blocks: The observing blocks to schedule.  Note that the input
                     `~astroplan.scheduling.ObservingBlock` objects will *not* be
                     modified - new ones will be created and returned.
      :type blocks: list of `~astroplan.scheduling.ObservingBlock` objects
      :param schedule: A schedule that the blocks will be scheduled in. At this time
                       the ``schedule`` must be empty, only defined by a start and
                       end time.
      :type schedule: `~astroplan.scheduling.Schedule` object

      :returns: **schedule** -- A schedule objects which consists of `~astroplan.scheduling.Slot`
                objects with and without populated ``block`` objects containing either
                `~astroplan.scheduling.TransitionBlock` or `~astroplan.scheduling.ObservingBlock`
                objects with populated ``start_time`` and ``end_time`` or ``duration`` attributes
      :rtype: `~astroplan.scheduling.Schedule`


   .. method:: _make_schedule(self, blocks)
      :abstractmethod:


      Does the actual business of scheduling. The ``blocks`` passed in should
      have their ``start_time` and `end_time`` modified to reflect the
      schedule. Any necessary `~astroplan.scheduling.TransitionBlock` should
      also be added.  Then the full set of blocks should be returned as a list
      of blocks, along with a boolean indicating whether or not they have been
      put in order already.

      :param blocks: Can be modified as it is already copied by ``__call__``
      :type blocks: list of `~astroplan.scheduling.ObservingBlock` objects

      :returns: **schedule** -- A schedule objects which consists of `~astroplan.scheduling.Slot`
                objects with and without populated ``block`` objects containing either
                `~astroplan.scheduling.TransitionBlock` or `~astroplan.scheduling.ObservingBlock`
                objects with populated ``start_time`` and ``end_time`` or ``duration`` attributes.
      :rtype: `~astroplan.scheduling.Schedule`


   .. method:: from_timespan(cls, center_time, duration, **kwargs)
      :classmethod:


      Create a new instance of this class given a center time and duration.

      :param center_time: Mid-point of time-span to schedule.
      :type center_time: `~astropy.time.Time`
      :param duration: Duration of time-span to schedule
      :type duration: `~astropy.units.Quantity` or `~astropy.time.TimeDelta`



.. py:class:: SequentialScheduler(*args, **kwargs)

   Bases: :class:`spe_schedule.Scheduler`

   A scheduler that does "stupid simple sequential scheduling".  That is, it
   simply looks at all the blocks, picks the best one, schedules it, and then
   moves on.

   .. method:: _make_schedule(self, blocks)


      Does the actual business of scheduling. The ``blocks`` passed in should
      have their ``start_time` and `end_time`` modified to reflect the
      schedule. Any necessary `~astroplan.scheduling.TransitionBlock` should
      also be added.  Then the full set of blocks should be returned as a list
      of blocks, along with a boolean indicating whether or not they have been
      put in order already.

      :param blocks: Can be modified as it is already copied by ``__call__``
      :type blocks: list of `~astroplan.scheduling.ObservingBlock` objects

      :returns: **schedule** -- A schedule objects which consists of `~astroplan.scheduling.Slot`
                objects with and without populated ``block`` objects containing either
                `~astroplan.scheduling.TransitionBlock` or `~astroplan.scheduling.ObservingBlock`
                objects with populated ``start_time`` and ``end_time`` or ``duration`` attributes.
      :rtype: `~astroplan.scheduling.Schedule`



.. py:class:: PriorityScheduler(*args, **kwargs)

   Bases: :class:`spe_schedule.Scheduler`

   A scheduler that optimizes a prioritized list.  That is, it
   finds the best time for each ObservingBlock, in order of priority.

   .. method:: _get_filled_indices(self, times)



   .. method:: _get_date(self, times)



   .. method:: _make_schedule(self, blocks)


      Does the actual business of scheduling. The ``blocks`` passed in should
      have their ``start_time` and `end_time`` modified to reflect the
      schedule. Any necessary `~astroplan.scheduling.TransitionBlock` should
      also be added.  Then the full set of blocks should be returned as a list
      of blocks, along with a boolean indicating whether or not they have been
      put in order already.

      :param blocks: Can be modified as it is already copied by ``__call__``
      :type blocks: list of `~astroplan.scheduling.ObservingBlock` objects

      :returns: **schedule** -- A schedule objects which consists of `~astroplan.scheduling.Slot`
                objects with and without populated ``block`` objects containing either
                `~astroplan.scheduling.TransitionBlock` or `~astroplan.scheduling.ObservingBlock`
                objects with populated ``start_time`` and ``end_time`` or ``duration`` attributes.
      :rtype: `~astroplan.scheduling.Schedule`


   .. method:: attempt_insert_block(self, b, new_start_time, start_time_idx)




.. py:class:: Transitioner(slew_rate=None, instrument_reconfig_times=None)

   Bases: :class:`object`

   A class that defines how to compute transition times from one block to
   another.

   .. method:: __call__(self, oldblock, newblock, start_time, observer)


      Determines the amount of time needed to transition from one observing
      block to another.  This uses the parameters defined in
      ``self.instrument_reconfig_times``.

      :param oldblock: The initial configuration/target
      :type oldblock: `~astroplan.scheduling.ObservingBlock` or None
      :param newblock: The new configuration/target to transition to
      :type newblock: `~astroplan.scheduling.ObservingBlock` or None
      :param start_time: The time the transition should start
      :type start_time: `~astropy.time.Time`
      :param observer: The observer at the time
      :type observer: `astroplan.Observer`

      :returns: **transition** -- A transition to get from ``oldblock`` to ``newblock`` or `None` if
                no transition is necessary
      :rtype: `~astroplan.scheduling.TransitionBlock` or None


   .. method:: compute_instrument_transitions(self, oldblock, newblock)




.. py:class:: DateElsa(*args, **kwargs)

   Bases: :class:`spe_schedule.Scheduler`

   Gives the start and end of a block chosen.

   .. method:: start_and_end(self, times)




.. py:class:: SimpleScheduler(*args, **kwargs)

   Bases: :class:`spe_schedule.Scheduler`

   schedule blocks randomly

   .. method:: _make_schedule(self, blocks)


      Does the actual business of scheduling. The ``blocks`` passed in should
      have their ``start_time` and `end_time`` modified to reflect the
      schedule. Any necessary `~astroplan.scheduling.TransitionBlock` should
      also be added.  Then the full set of blocks should be returned as a list
      of blocks, along with a boolean indicating whether or not they have been
      put in order already.

      :param blocks: Can be modified as it is already copied by ``__call__``
      :type blocks: list of `~astroplan.scheduling.ObservingBlock` objects

      :returns: **schedule** -- A schedule objects which consists of `~astroplan.scheduling.Slot`
                objects with and without populated ``block`` objects containing either
                `~astroplan.scheduling.TransitionBlock` or `~astroplan.scheduling.ObservingBlock`
                objects with populated ``start_time`` and ``end_time`` or ``duration`` attributes.
      :rtype: `~astroplan.scheduling.Schedule`



