:mod:`long_term_scheduler`
==========================

.. py:module:: long_term_scheduler


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   long_term_scheduler.Schedules



Functions
~~~~~~~~~

.. autoapisummary::

   long_term_scheduler.max_unit_list
   long_term_scheduler.first_elem_list
   long_term_scheduler.last_elem_list
   long_term_scheduler.coord_transfotm_to_alt
   long_term_scheduler.index_list1_list2
   long_term_scheduler.Diff_list
   long_term_scheduler.SSO_planned_targets
   long_term_scheduler.SNO_planned_targets
   long_term_scheduler.TS_planned_targets
   long_term_scheduler.TN_planned_targets
   long_term_scheduler.target_list_good_coord_format
   long_term_scheduler.charge_observatories
   long_term_scheduler._generate_24hr_grid
   long_term_scheduler.altaz
   long_term_scheduler.Observability
   long_term_scheduler.reverse_Observability
   long_term_scheduler.month_option
   long_term_scheduler.save_schedule
   long_term_scheduler.make_plans
   long_term_scheduler.read_night_block
   long_term_scheduler.make_docx_schedule
   long_term_scheduler.date_range_in_days


.. function:: max_unit_list(x)

   return max of list

   :param x:
   :type x: list

   :returns: max of list
   :rtype: float


.. function:: first_elem_list(x)

   first element of list

   :param x:
   :type x: list

   :returns: first element of list
   :rtype: float


.. function:: last_elem_list(x)

   last element of list

   :param x:
   :type x: list

   :returns: last element
   :rtype: float


.. function:: coord_transfotm_to_alt(x, frame)

   transform astropy.coordinates to a given frame

   :param x:
   :type x: astropy.coordinates
   :param coordinates:
   :param frame: frame in astropy.coordinates
   :type frame: str

   :returns: coordinates in the frame chosen
   :rtype: astropy.coordinates


.. function:: index_list1_list2(list1, list2)

   index of list1 in list2 and list2 in list1

   :param list1:
   :type list1: list
   :param list2:
   :type list2: list

   :returns: list of index of list1 in list2 and list2 in list1
   :rtype: list


.. function:: Diff_list(li1, li2)

   Inform on the difference between two lists

   :param li1:
   :type li1: list
   :param li2:
   :type li2: list

   :returns: Elements than are in list 1 but not in list 2
   :rtype: list


.. function:: SSO_planned_targets(date, telescope)

   tell which target are scheduled on SSO on a given day

   :param date: date of day in fmt 'yyyy-mm-dd'
   :type date: date
   :param telescope: name of telescope
   :type telescope: str

   :returns: list of targets scheduled on this SSO telescope that  day
   :rtype: list


.. function:: SNO_planned_targets(date)

   tell which target are scheduled on SNO on a given day

   :param date: date of day in fmt 'yyyy-mm-dd'
   :type date: date

   :returns: list of targets scheduled on this SNO that  day
   :rtype: list


.. function:: TS_planned_targets(date)

   tell which target are scheduled on TS on a given day

   :param date: date of day in fmt 'yyyy-mm-dd'
   :type date: date

   :returns: list of targets scheduled on this TS that  day
   :rtype: list


.. function:: TN_planned_targets(date)

   tell which target are scheduled on TN on a given day

   :param date: date of day in fmt 'yyyy-mm-dd'
   :type date: date

   :returns: list of targets scheduled on this TN that  day
   :rtype: list


.. function:: target_list_good_coord_format(path_target_list)

   Give target corrdinates in ICRS format (used for astropy.coordinates SkyCoord function)

   :param path_target_list: path on your computer toward the target list, by default take the one on the Cambridge server
   :type path_target_list: str

   :returns: **targets** -- targets list with the following format : [<FixedTarget "Sp0002+0115" at SkyCoord (ICRS): (ra, dec) in deg (0.52591667, 1.26003889)>,
   :rtype: astropy.FixedTarget


.. function:: charge_observatories(Name)

   :param Name: name of the observatory (ex: 'SSO')
   :type Name: str

   :returns: all info on observatory loaded
   :rtype: astroplan.observer


.. function:: _generate_24hr_grid(t0, start, end, N, for_deriv=False)

   Generate a nearly linearly spaced grid of time durations.
   The midpoints of these grid points will span times from ``t0``+``start``
   to ``t0``+``end``, including the end points, which is useful when taking
   numerical derivatives.
   :param t0: Time queried for, grid will be built from or up to this time.
   :type t0: `~astropy.time.Time`
   :param start: Number of days before/after ``t0`` to start the grid.
   :type start: float
   :param end: Number of days before/after ``t0`` to end the grid.
   :type end: float
   :param N: Number of grid points to generate
   :type N: int
   :param for_deriv: Generate time series for taking numerical derivative (modify
                     bounds)?
   :type for_deriv: bool

   :returns:
   :rtype: `~astropy.time.Time`


.. function:: altaz(self, time, target=None, obswl=None, grid_times_targets=False)

   Get an `~astropy.coordinates.AltAz` frame or coordinate.
   If ``target`` is None, generates an altitude/azimuth frame. Otherwise,
   calculates the transformation to that frame for the requested ``target``.

   :param time: The time at which the observation is taking place.
   :type time: astropy.time.Time
   :param target: Celestial object(s) of interest.
   :type target: astroplan.FixedTarget
   :param obswl: Wavelength of the observation used in the calculation.
   :type obswl: astropy.units.Quantity
   :param grid_times_targets: If True, the target object will have extra dimensions packed onto the end. Otherwise, we rely on broadcasting the shapes together using standard numpy rules. Useful for grid searches for rise/set times etc.
   :type grid_times_targets: bool (optional)

   :returns:
   :rtype: astropy.coordinates.AltAz


.. function:: Observability(j, time_range, observatory, targets, constraints)

   Give a table with the observability score for each target of targets
   regarding the constraints given and for all ranges of time_range

   :param j: [start end], element of time range (that is to say, month of the year)
   :type j: list
   :param time_range: of astropy.Time range with start and end times
   :type time_range: list
   :param observatory: observatory chosen
   :type observatory: astroplan.observer
   :param targets: target list on the FixedTarget() format from astroplan
   :type targets: astropy
   :param constraints: general constraints for a target to be shceduled
   :type constraints: astroplan.constraint

   :returns: * **Observability table** (*astropy.table.Table*) -- 12 columns (target name and each element of time_range, e.g months),
             * *rows= nb of targets*


.. function:: reverse_Observability(observatory, targets, constraints, time_ranges)

   Reverse observability table, rows become columns
   :param observatory: observatory chosen
   :type observatory: str
   :param time_range: List of astropy.Time range with start and end times
   :type time_range: list
   :param targets: target list on the FixedTarget() format from astroplan
   :type targets: list of astropy.FixedTarget
   :param constraints: general constraints for a target to be shceduled
   :type constraints: astroplan.constraints

   :returns: **reverse_df1** -- observability table with no NaN value (0 instead) inversed with targets as columns
             and elements of time_ranges (months) as rows
   :rtype: astropy.table


.. function:: month_option(target_name, reverse_df1)

   create a list of the best month for oservation for each target

   :param target_name: name of the target
   :type target_name: str
   :param reverse_df1: observability table with no NaN value (0 instead) inversed with targets as columns and elements of time_ranges (months) as rows
   :type reverse_df1: astropy.table

   :returns: * **month** (*list*) -- a list with the best month to observe the target
             * **month_2nd_option** (*list*) -- same but for the second best month
             * **months_3rd_option** (*list*) -- same but for the third best month
             * **months_4th_option** (*list*) -- same but for the fourth best month
             * **months_5th_option** (*list*) -- same but for the fiveth best month
             * *Remarks*
             * *-------*
             * *the 2nd, 3rd etc choices are here in case the target list is not long enough to give*
             * *solutions for all the telescopes each months, allows to avoid blancks in observations*


.. function:: save_schedule(input_file, nb_observatory, save, over_write, date_range, telescope)

   save schedules in destination

   :param input_file: input file for SPOCKLT
   :type input_file: file
   :param nb_observatory: name of the observatory
   :type nb_observatory: str
   :param save: True if want to save, False if not
   :type save: bool
   :param over_write: True if want overwrite, False if not
   :type over_write: bool
   :param date_range: list with 2 elements, start date  and end date
   :type date_range: list of date
   :param telescope: name of telescope for which you which to save the schedules
   :type telescope: str

   :returns:
   :rtype: message


.. function:: make_plans(day, nb_days, telescope)

   make plans for telescope for a certain number of day from a start day

   :param day: day
   :type day: int
   :param nb_days: number of days
   :type nb_days: int
   :param telescope: name telescope
   :type telescope: string


.. py:class:: Schedules

   Class to Make schedules for the target list, observatory, date_range and startegy indicated

   .. method:: idx_rise_targets_sorted(self)
      :property:


      index for rise targets sorted

      :returns: index of rise targets sorted
      :rtype: list of int


   .. method:: idx_set_targets_sorted(self)
      :property:


      index for set targets sorted

      :returns: index of set targets sorted
      :rtype: list of int


   .. method:: months_obs(self)
      :property:


      month of obs

      :returns: month number (between 0 and 11)
      :rtype: int


   .. method:: date_range_in_days(self)
      :property:


      number of days in date range

      :returns: number of day between date start and date end
      :rtype: int


   .. method:: nb_hours_threshold(self)
      :property:


      number of hours to reach

      :returns: list as long as the target list
      :rtype: list


   .. method:: date_ranges_day_by_day(self)
      :property:


      date range day by day

      :returns: list of date ranges
      :rtype: list


   .. method:: nb_hours_observed(self)
      :property:


      nb hours observed for each target

      :returns: nb hours observed
      :rtype: list


   .. method:: exposure_time_table(self, day)


      generate an exposure time table as the form of a file untitled

      :param day: date in fmt 'yyyy-mm-dd'
      :type day: date

      :returns: file with most appropriate exposure time for each target "exposure_time_table.csv"
      :rtype: file


   .. method:: idx_SSO_observed_targets(self)



   .. method:: idx_SNO_observed_targets(self)



   .. method:: idx_SaintEx_observed_targets(self)



   .. method:: idx_trappist_observed_targets(self)



   .. method:: load_parameters(self, input_file, nb_observatory)



   .. method:: make_schedule(self, Altitude_constraint=None, Moon_constraint=None)



   .. method:: idx_targets(self, t)


      Give the index of the first and second targets as well as the
          corresponding row in the priority table


      :returns: * **idx_first_target** (*int*) -- index first target in target list
                * **first_target** (*int*) -- row number idx_first_target in priority table
                * **idx_second_target** (*int*) -- index second target in target list
                * **second_target** (*row number idx_second_target in priority table*)


   .. method:: table_priority_prio(self, day)



   .. method:: observability_seclection(self, day)



   .. method:: shift_hours_observation(self, idx_target)



   .. method:: schedule_blocks(self, day)


      schedule the lock thanks to astroplan tools

      :param idx_first_target:
      :type idx_first_target: int, index of the first target
      :param idx_second_target:
      :type idx_second_target: int, index of the second target

      :returns: * **SS1_night_blocks** (*astropy.table with name, start time, end time, duration ,*)
                * *coordinates (RE and DEC) and configuration (filter and exposure time) for each target of the night*


   .. method:: make_night_block(self, day)



   .. method:: is_constraint_hours(self, idx_target)


      Check if number of hours is ok

      :param idx_target:
      :type idx_target: int, index of the target you want to check

      :returns: **is_hours_constraint_met_target**
      :rtype: boolean, say the hour constraint is ok or not


   .. method:: night_duration(self, day)


      :param day: day str format '%y%m%d HH:MM:SS.sss'
      :return:


   .. method:: info_obs_possible(self, day)


      :param day: day str format '%y%m%d HH:MM:SS.sss'
      :return:


   .. method:: rise_time_targets(self, day)


      :param day: day str format '%y%m%d HH:MM:SS.sss'
      :return:


   .. method:: set_time_targets(self, day)


      :param day: day str format '%y%m%d HH:MM:SS.sss'
      :return:


   .. method:: idx_is_julien_criterion(self, day)


      :param day: day str format '%y%m%d HH:MM:SS.sss'
      :return:


   .. method:: is_moon_and_visibility_constraint(self, day)


      Check if number of moon not too close and target is visible

      :param idx_target:
      :type idx_target: int, index of the target you want to check

      :returns: **is_hours_constraint_met_target**
      :rtype: boolean, say the hour constraint is ok or not


   .. method:: is_constraints_met_first_target(self, t)


      Useful when the moon constrain (< 30°) or the hours constraint (nb_hours_observed>nb_hours_threshold)
          are not fullfilled anymore and the first target needs to be changed

      :param t:
      :type t: int, days in the month
      :param idx_first_target:
      :type idx_first_target: int, index associated to the first target (with regards to the targets list)
      :param idx_set_targets_sorted:
      :type idx_set_targets_sorted: list of int, index of all the set target ranked y priority
      :param idx_rise_targets_sorted:
      :type idx_rise_targets_sorted: list of int, index of all the rise target ranked y priority
      :param index_prio:
      :type index_prio: list of int, index of all the rise target ranked y priority

      :returns: * **is_moon_constraint_met_first_target** (*boolean, say if moon constraint is fullfilled on first target*)
                * **hours_constraint** (*boolean, say if hour constraint is fullfilled on first target*)
                * **idx_first_target** (*int, index for the first target (if constraints where already fullfilled the Value*)
                * *is the same as input, else it is a new value for a new target)*


   .. method:: is_constraints_met_second_target(self, t)


      Useful when the moon constrain (< 30°) or the hours constraint (nb_hours_observed>nb_hours_threshold)
          are not fullfilled anymore and the second target needs to be changed

      :param t:
      :type t: int, days in the month
      :param idx_first_target:
      :type idx_first_target: int, index associated to the first target (with regards to the targets list)
      :param idx_second_target:
      :type idx_second_target: int, index associated to the second target (with regards to the targets list)
      :param idx_set_targets_sorted:
      :type idx_set_targets_sorted: list of int, index of all the set target ranked y priority
      :param idx_rise_targets_sorted:
      :type idx_rise_targets_sorted: list of int, index of all the rise target ranked y priority
      :param index_prio:
      :type index_prio: list of int, index of all the rise target ranked y priority

      :returns: * **is_moon_constraint_met_second_target** (*boolean, say if moon constraint is fullfilled on second target*)
                * **hours_constraint** (*boolean, say if hour constraint is fullfilled on second target*)
                * **idx_second_target** (*int, index for the second target (if constraints where already fullfilled the Value*)
                * *is the same as input, else it is a new value for a new target)*


   .. method:: update_hours_observed_first(self, day)


      update number of hours observed for the corresponding first target

      :param t:
      :type t: int, day of the month
      :param idx_first_target:
      :type idx_first_target: int, index of the first target

      :returns: * *self.nb_hours_observed*
                * *self.nb_hours*
                * *self.nb_hours[idx_first_target]*


   .. method:: update_hours_observed_second(self, day)


      update number of hours observed for the corresponding second target

      :param t:
      :type t: int, day of the month
      :param idx_second_target:
      :type idx_second_target: int, index of the second target

      :returns: * *self.nb_hours_observed*
                * *self.nb_hours*
                * *self.nb_hours[idx_second_target]*


   .. method:: make_plan_file(self, day)



   .. method:: reference_table(self)



   .. method:: exposure_time_for_table(self, obs, day, i)


      calcul of exposure time to store in a table

      :param obs: name of observatory
      :type obs: str
      :param day: day for moon phse calcultation (fmt 'yyyy-mm-dd')
      :type day: date
      :param i: target index in target list
      :type i: int

      :returns: exposure time
      :rtype: float


   .. method:: exposure_time(self, day, i)


      calculation of the exposure time for a given target

      :param day: format 'yyyy-mm-dd'
      :type day: date
      :param i: index of target in target_list
      :type i: int

      :returns: exposure time
      :rtype: float


   .. method:: no_obs_with_different_tel(self)


      function to avoid observations of a similar target,
      expect for SNO and SAINT-EX were similar target observations are encouraged.

      :returns: fill with 0 priority of targets already scheduled
      :rtype: self.priority



.. function:: read_night_block(telescope, day)

   [summary]

   :param telescope: [description]
   :type telescope: [type]
   :param day: [description]
   :type day: [type]

   :returns: [description]
   :rtype: [type]


.. function:: make_docx_schedule(observatory, telescope, date_range, name_operator, path_target_list)


.. function:: date_range_in_days(date_range)


